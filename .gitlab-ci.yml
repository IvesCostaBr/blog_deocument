image: node  #imagem que será usada pelo runner

#nivel Global

#TODO:[ STAGES ] São os estagios de Jobs que por Defalt são criados
stages:
  - test
  - packege
  - deploy

before_script: #ele é executado em todos os jobs/script
  - whoami
  - pwd

testing site:
  stage: test
  before_script:
    - npm install -g broken-link-checker@0.7.8  wait-on@6.0.0
  script:
    - cd website
    - npm install && npm run start &
    - wait-on http://localhost:3000/
    - blc --recursive --exclude-external http://localhost:3000/
  only:
    - develop

#TODO:[ BUILD JOB ] build é apenas um [*alias de prefixo] e site é o nome do job
packege site: 
  stage: packege  #setando o stage packege nesse job, ou seja falando que esse job pertence ao build
  #TODO: [CACHE] é farmo de levar arquivos de um joob para um outro
  cache:
    #[ KEY  ] é responsavel por dar uma indentificação do cache , pois podemos ter mais de um
    key: site-packege 
    #[ POLICY ] Depois que fizer todo o joob vai pegar o diretorio e fazer um push para os proximos job
    policy: push  
  artifacts:  #Artifacts ele fala pro runner expor esses determiandos arquivos para download
    name: "$CI_JOB_NAME-$CI_COMMIT_REF_NAME"
    when: always
    expire_in: 2h20min
    paths:
      - ./website/build/test-site  
  #TODO: [SCRIPT] é oque vai ser executado naquel job unico campo obrigatorio faria rodar uma pipeline
  script:  
    - ls -ltra 
    - cd website
    - npm install 
    - npm run build

vulnerabilities check:
  stage: test
  script:
    - cd website && npm install && npm run scan

  only:
    - develop


#TODO:----CD Continuos Delivery
deploy to staging: &deploy #anchor  exporta esses parametros
  stage: deploy
  variables:
    #TODO: [VARIABLE] criação de variaveis locais dentro do joob/E pode ser criado global tambem
    CNAME: staging-ivessantoscosta.surge.sh 
    GIT_STRATEGY: none
  cache:
    #[ KEY  ] é responsavel por dar uma indentificação do cache , pois podemos ter mais de um
    key: site-packege 
    #[ POLICY ] Depois que fizer todo o joob vai pegar o diretorio e fazer um push para os proximos job
    policy: pull  
  #TODO: [ BEFORE SCRIPT ] como ele já possui um before script no nivel local , então vai executar o do nivel global
  before_script: 
    - npm install -g surge@^0.20.1
  script:
    - surge --project ./website/build/test-site --domain ${CNAME}
  
  #TODO: [AFTER SCRIPT] é executado mesmo se o script falhar, no caso o local
  after_script:
    - whoami
  environment:
    name: staging
    url: https://${CNAME}
  #TODO: [ Only ] Só será executado sé a politica ( estiver na branch develop)
  only:
    - develop


#TODO:Criando Branch de release
deploy to release: &deploy-release
  <<: *deploy   #Injeta a ancora dentro desse job 
  variables:
    CNAME: $CI_COMMIT_REF_SLUG.ivescosta.surge.sh
    GIT_STRATEGY: none 
  environment:
    name: develop
    on_stop: turnoff
  only:
    - /^release-.*$/
  
turnoff:
  <<: *deploy #caso precise fazer sobrescrita basta apagar o campo e colocar o seu que ele vai reconhecer
  script:
    - surge  teardown ${CNAME}
  when:
    manual
  environment:
    name: develop
    url: https://${CNAME}
    action: stop

deploy to production:
  image: amazonlinux
  <<: *deploy
  stage: deploy
  variables:
    #TODO: [VARIABLE] criação de variaveis locais dentro do joob/E pode ser criado global tambem
    CNAME: ivessantoscosta.surge.sh 
    S3_BACKET: s3://cerberus-site
  before_script:
    - curl https://bootstrap.pypa.io/get-pip.py && python get-pip.py
    - pip install awscli --upgrade --user && export PATH=-/.local/bin:$PATH 
    - aws --version
  script:
    - aws s3 ls $(S3_BUCKET)
    - cd website/build/test-site && pwd && ls -ltra
    - aws s3 rm $(S3_BUCKET) --acl public-read --recursive
  environment:
    name: production
    url: https://${CNAME}
  #TODO: [ Only ] Só será executado sé a politica ( estiver na branch develop)
  only:
    - master